function checkOcclusion(planes, plane_index)
  target_plane = planes(plane_index);
  images = target_plane.images;
%  for i = 1:size(images)
  for i = 21:21
      camera_pt_world = images(i).t;
      
      % sections are in plane coordinates
      sections = [];
      sectionsX = 3;
      sectionsY = 3;
      curr_box = images(i).mytile_on_plane.box;
      gridStepY = (curr_box.row_max - curr_box.row_min + 1)/sectionsY;
      gridStepX = (curr_box.col_max - curr_box.col_min + 1)/sectionsX;
      for j = 1:sectionsY
          for k = 1:sectionsX
              %not integers but should be ok
              section.min_row = round(((j-1) * gridStepY)+1);
              section.max_row = round(j * gridStepY);
              section.min_col = round(((k-1) * gridStepX)+1);
              section.max_col = round(k * gridStepX);
              section.center = [(section.max_row+section.min_row)/2; (section.max_col+section.min_col)/2];
              sections = [sections section];
          end
      end
      for j = 1:size(sections,2)
          section = sections(j);
          center_pt_plane = section.center;
          center_pt_world = target_plane.get_world_pts(center_pt_plane);
          if isoccluded(center_pt_world, camera_pt_world, planes, plane_index)
              empty_patch = zeros(section.max_row-section.min_row+1,section.max_col-section.min_col+1);
              empty_patch = repmat(empty_patch, [1,1,3]);
              target_plane.images(i).mytile_on_plane.data(section.min_row:section.max_row,section.min_col:section.max_col,:) = empty_patch;
          end
      end
  end


end


%liberally copied from stewart's occlusion check in Plane::occlusionCheck
function occluded = isoccluded(dest, source, planes, plane_to_ignore)
    occluded = false;
    dir = dest - source;
    for i = 1:size(planes,2)
        p = planes(i);
        if i == plane_to_ignore
            % don't test occlusion with self
            continue;
        end
        % find intersection between line and unbounded plane
        % n dot v = d where n is normal, d is plane offset
        % so n dot (center + dir*t) = d
        nDotCenter = p.normal * source;
        nDotDir = p.normal * dir;
        t = (-p.d - nDotCenter)/nDotDir;
        pointOfIntersection = source + dir * t;
        if (t <= 0) || (t >= 1)
            % doesn't come between our dest and source
            continue;
        end
        
        % now project to 2d and count number of times ray intersects plane
        % boundary.
        nx = p.normal(0);
        ny = p.normal(1);
        nz = p.normal(2);
        index0 = -1;
        index1 = -1;
        if (abs(nz) > abs(nx)) && (abs(nz) > abs(ny))
            index0 = 0;
            index1 = 1;
        elseif (abs(ny) > abs(nx))
            index0 = 0;
            index1 = 2;
        else
            index0 = 1;
            index1 = 2;
        end
        xp = pointOfIntersection(index0);
        yp = pointOfIntersection(index1);
        delimitingPoints = zeros(size(p.vertices),2);
        for j = 1:size(p.vertices)
           delimitingPoints(j,1) = p.vertices(j, index0);
           delimitingPoints(j,2) = p.vertices(j, index1);
        end
        checkPoint = [xp,yp];
        if polygonCheck(checkPoint, delimitingPoints)
            occluded = true;
        end
        if occluded
            break;
        end
    end
end

function inside = polygonCheck(checkPoint, delimitingPoints)
  % odd number of crossings means inside
  inside = false;
  j = size(delimitingPoints);
  for i = 1:size(delimitingPoints)
      if (((delimitingPoints(i,2) > checkPoint.y) ~= (delimitingPoints(j,2))
      j = i;
      i = i+1;
  end
end