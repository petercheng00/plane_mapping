function checkOcclusion(planes, plane_index)
  target_plane = planes(plane_index);
  images = target_plane.images;
  for i = 1:size(images,2)
      curr_box = images(i).mytile_on_plane.orig_box;
      gridStepY = 400;
      gridStepX = 400;
      maxSubDivs = 4;
      numSectionsY = ceil((curr_box.row_max - curr_box.row_min + 1)/gridStepY);
      numSectionsX = ceil((curr_box.col_max - curr_box.col_min + 1)/gridStepX);
      keyboard
      for j = 1:numSectionsY
          for k = 1:numSectionsX
              row_min = curr_box.row_min + (j-1) * gridStepY;
              row_max = min(curr_box.row_min + (j * gridStepY), curr_box.row_max);
              col_min = curr_box.col_min + (k-1) * gridStepX;
              col_max = min(curr_box.col_min + (k * gridStepX), curr_box.col_max);
              subdivideForOcclusion(planes, plane_index, i, 0, maxSubDivs, ...
                  row_min, row_max, col_min, col_max);
          end
      end
      keyboard
      if sum(sum(target_plane.images(i).mytile_on_plane.orig_valid)) > 0
          target_plane.images(i).mytile_on_plane = target_plane.images(i).mytile_on_plane.crop();
          target_plane.images(i).mytile_on_plane = target_plane.images(i).mytile_on_plane.set_border_mask(target_plane.blendpx);
      else
          target_plane.images(i).useful = false;
      end
  end
end

function subdivideForOcclusion(planes, plane_index, imgnum, depth, maxDepth, ...
                        row_min, row_max, col_min, col_max)
  target_plane = planes(plane_index);
  %if depth == maxDepth
  %    occludeRectangle(target_plane, imgnum, row_min, row_max, col_min, col_max);
  %    return
  %end    
  box = target_plane.images(imgnum).mytile_on_plane.orig_box;
  data = target_plane.images(imgnum).mytile_on_plane.orig_data;
  if sum(sum(sum(data(row_min-box.row_min+1:row_max-box.row_min+1,...
          col_min-box.col_min+1:col_max-box.col_min+1,:)))) == 0
      return;
  end
  
  camera_pt_world = target_plane.images(imgnum).t;
  LL_pt_plane = [row_max; col_min];
  LL_pt_world = target_plane.get_world_pts(LL_pt_plane);
  UL_pt_plane = [row_min; col_min];
  UL_pt_world = target_plane.get_world_pts(UL_pt_plane);
  UR_pt_plane = [row_min; col_max];              
  UR_pt_world = target_plane.get_world_pts(UR_pt_plane);
  LR_pt_plane = [row_max; col_max];              
  LR_pt_world = target_plane.get_world_pts(LR_pt_plane);
  
  % 5 test points = 4 corners + center point
  % not using center, can't think of a good use
  % if all are bad, then occlude the entire section.
  % if none are bad, do nothing
  % else subdivide and do a recursive call
  LL_result = occludedOrOffPlane(planes, plane_index, LL_pt_world, camera_pt_world);
  UL_result = occludedOrOffPlane(planes, plane_index, UL_pt_world, camera_pt_world);
  UR_result = occludedOrOffPlane(planes, plane_index, UR_pt_world, camera_pt_world);
  LR_result = occludedOrOffPlane(planes, plane_index, LR_pt_world, camera_pt_world);
  
  if LL_result && UL_result && UR_result && LR_result
      occludeRectangle(target_plane, imgnum, row_min, row_max, col_min, col_max);
      return
  end     
  
  if ~LL_result && ~UL_result && ~UR_result && ~LR_result
      return
  end
  if 1
      if depth == maxDepth  
        %if sum([LL_result, UL_result, UR_result, LR_result]) == 1
        %    keyboard
        %    if LL_result
        %        occludeTriangle('LL', target_plane, imgnum, row_min, row_max, col_min, col_max);
        %    end
        %    if UL_result
        %        occludeTriangle('UL', target_plane, imgnum, row_min, row_max, col_min, col_max);
        %    end
        %%    if UR_result
        %        occludeTriangle('UR', target_plane, imgnum, row_min, row_max, col_min, col_max);
        %    end
        %    if LR_result
        %        occludeTriangle('LR', target_plane, imgnum, row_min, row_max, col_min, col_max);
        %    end
        %    keyboard
        if sum([LL_result, UL_result, UR_result, LR_result]) == 2
            if LL_result && UL_result
                occludeRectangle(target_plane, imgnum, row_min, row_max, col_min, round((col_min+col_max)/2));
            end
            if UL_result && UR_result
                occludeRectangle(target_plane, imgnum, row_min, round((row_min+row_max)/2), col_min, col_max);
            end
            if UR_result && LR_result
                occludeRectangle(target_plane, imgnum, round((row_min+row_max)/2), row_max, round((col_min+col_max)/2), col_max);
            end
            if LR_result && LL_result
                occludeRectangle(target_plane, imgnum, round((row_min+row_max)/2), row_max, col_min, col_max);
            end
        elseif sum([LL_result, UL_result, UR_result, LR_result]) == 3
            if ~LL_result
                occludeTriangle('UR', target_plane, imgnum, row_min, row_max, col_min, col_max);
            end
            if ~UL_result
                occludeTriangle('LR', target_plane, imgnum, row_min, row_max, col_min, col_max);
            end
            if ~UR_result
                occludeTriangle('LL', target_plane, imgnum, row_min, row_max, col_min, col_max);
            end
            if ~LR_result
                occludeTriangle('UL', target_plane, imgnum, row_min, row_max, col_min, col_max);
            end
        end
        return
      end
  end
  subdivideForOcclusion(planes, plane_index, imgnum, depth+1, maxDepth, ...
      row_min, round((row_max+row_min)/2), col_min, round((col_max+col_min)/2));
  subdivideForOcclusion(planes, plane_index, imgnum, depth+1, maxDepth, ...
      row_min, round((row_max+row_min)/2), round((col_max+col_min)/2), col_max);
  subdivideForOcclusion(planes, plane_index, imgnum, depth+1, maxDepth, ...
      round((row_max+row_min)/2), row_max, col_min, round((col_max+col_min)/2));
  subdivideForOcclusion(planes, plane_index, imgnum, depth+1, maxDepth, ...
      round((row_max+row_min)/2), row_max, round((col_max+col_min)/2), col_max);

end

function invalid = occludedOrOffPlane(planes, plane_index, plane_pt, source_pt)
  [center_2d, vertices_2d] = project_2d(planes(plane_index), plane_pt);
  onPlane = polygonCheck(center_2d, vertices_2d);
  invalid = (~onPlane) || (isoccluded(plane_pt, source_pt, planes, plane_index));
end

function occludeRectangle(target_plane, imgnum, row_min, row_max, col_min, col_max)
  curr_box = target_plane.images(imgnum).mytile_on_plane.orig_box;
  empty_patch = zeros(row_max-row_min+1,col_max-col_min+1);
  target_plane.images(imgnum).mytile_on_plane.orig_valid(row_min-curr_box.row_min+1:row_max-curr_box.row_min+1, ... 
      col_min-curr_box.col_min+1:col_max-curr_box.col_min+1) = empty_patch;
  target_plane.images(imgnum).mytile_on_plane.orig_data(row_min-curr_box.row_min+1:row_max-curr_box.row_min+1, ... 
      col_min-curr_box.col_min+1:col_max-curr_box.col_min+1,:) = repmat(empty_patch,[1,1,3]);


  cropped_box = target_plane.images(imgnum).mytile_on_plane.cropped_box;
  cropped_row_min = min(max(1, row_min - cropped_box.row_min+1),cropped_box.row_max-cropped_box.row_min+1);
  cropped_row_max = min(max(1, row_max - cropped_box.row_min+1),cropped_box.row_max-cropped_box.row_min+1);
  cropped_col_min = min(max(1, col_min - cropped_box.col_min+1),cropped_box.col_max-cropped_box.col_min+1);
  cropped_col_max = min(max(1, col_max - cropped_box.col_min+1),cropped_box.col_max-cropped_box.col_min+1);
  empty_patch = zeros(cropped_row_max-cropped_row_min+1,cropped_col_max-cropped_col_min+1);
  target_plane.images(imgnum).mytile_on_plane.cropped_valid(cropped_row_min:cropped_row_max, ... 
      cropped_col_min:cropped_col_max) = empty_patch;
  target_plane.images(imgnum).mytile_on_plane.cropped_data(cropped_row_min:cropped_row_max, ... 
      cropped_col_min:cropped_col_max,:) = repmat(empty_patch,[1,1,3]);
end


function occludeTriangle(corner, target_plane, imgnum, row_min, row_max, col_min, col_max)
  curr_box = target_plane.images(imgnum).mytile_on_plane.orig_box;
  % first create a patch with upper-left occluded, then flip as needed
  patch = zeros(row_max-row_min+1,col_max-col_min+1);
  
  h = round(size(patch,1)/2);
  w = round(size(patch,2)/2);
  
  % this method is fancier, but probably slower
  %x = 1:w;
  %i = round(h * (x-1) + h - ((h-1)/w) * x);
  %patch(i) = 0;
  %horiz_fill = ones(1,col_max-col_min+1);
  %temp_patch = patch;
  %for hh = 1:h
  %    temp_patch = [temp_patch(2:row_max,:);horiz_fill];
  %    patch = patch & temp_patch;
  %end
  
  for ww = 1:w
      depth = round(h - ((h-1)/w) * ww);
      patch(1:depth,ww) = 1;
  end
  % what we have done is the UL case
  if strcmp(corner, 'UR')
      patch = fliplr(patch);
  elseif strcmp(corner, 'LR')
      patch = fliplr(patch);
      patch = flipud(patch);
  elseif strcmp(corner, 'LL')
      patch = flipud(patch);
  end
  

  temp = target_plane.images(imgnum).mytile_on_plane.orig_valid(row_min-curr_box.row_min+1:row_max-curr_box.row_min+1, ... 
      col_min-curr_box.col_min+1:col_max-curr_box.col_min+1);
  temp(logical(patch)) = 0;
  target_plane.images(imgnum).mytile_on_plane.orig_valid(row_min-curr_box.row_min+1:row_max-curr_box.row_min+1, ... 
      col_min-curr_box.col_min+1:col_max-curr_box.col_min+1) = temp;
  
  temp = target_plane.images(imgnum).mytile_on_plane.orig_data(row_min-curr_box.row_min+1:row_max-curr_box.row_min+1, ... 
      col_min-curr_box.col_min+1:col_max-curr_box.col_min+1,:);
  temp(logical(repmat(patch,[1,1,3]))) = 0;
  target_plane.images(imgnum).mytile_on_plane.orig_data(row_min-curr_box.row_min+1:row_max-curr_box.row_min+1, ... 
      col_min-curr_box.col_min+1:col_max-curr_box.col_min+1,:) = temp;


  cropped_box = target_plane.images(imgnum).mytile_on_plane.cropped_box;
  cropped_row_min = min(max(1, row_min - cropped_box.row_min+1),cropped_box.row_max-cropped_box.row_min+1);
  cropped_row_max = min(max(1, row_max - cropped_box.row_min+1),cropped_box.row_max-cropped_box.row_min+1);
  cropped_col_min = min(max(1, col_min - cropped_box.col_min+1),cropped_box.col_max-cropped_box.col_min+1);
  cropped_col_max = min(max(1, col_max - cropped_box.col_min+1),cropped_box.col_max-cropped_box.col_min+1);
  patch = zeros(cropped_row_max-cropped_row_min+1,cropped_col_max-cropped_col_min+1);
  h = size(patch,1);
  w = size(patch,2);

  for ww = 1:w
      depth = round(h - ((h-1)/w) * ww);
      patch(1:depth,ww) = 1;
  end
  % what we have done is the UL case
  if strcmp(corner, 'UR')
      patch = fliplr(patch);
  elseif strcmp(corner, 'LR')
      patch = rot90(patch,2);
  elseif strcmp(corner, 'LL')
      patch = flipud(patch);
  end
  
  temp = target_plane.images(imgnum).mytile_on_plane.cropped_valid(cropped_row_min:cropped_row_max, ... 
      cropped_col_min:cropped_col_max);
  temp(logical(patch)) = 0;
  target_plane.images(imgnum).mytile_on_plane.cropped_valid(cropped_row_min:cropped_row_max, ... 
      cropped_col_min:cropped_col_max) = temp;
  
  temp = target_plane.images(imgnum).mytile_on_plane.cropped_data(cropped_row_min:cropped_row_max, ... 
      cropped_col_min:cropped_col_max,:);
  temp(logical(repmat(patch,[1,1,3]))) = 0;
  target_plane.images(imgnum).mytile_on_plane.cropped_data(cropped_row_min:cropped_row_max, ... 
      cropped_col_min:cropped_col_max,:) = temp;
end

%liberally copied from stewart's occlusion check in Plane::occlusionCheck
function occluded = isoccluded(dest, source, planes, plane_to_ignore)
    occluded = false;
    dir = dest - source;
    for i = 1:size(planes,2)
        if i == plane_to_ignore
            % don't test occlusion with self
            continue;
        end
        p = planes(i);
        if sum(p.normal == [0;0;1])==3 || sum(p.normal == [0;0;-1])==3
            % don't do intersection test with floors/ceilings, since often
            % we have weird cases with multiple ceilings
            continue;
        end
        % find intersection between line and unbounded plane
        % n dot v = d where n is normal, d is plane offset
        % so n dot (center + dir*t) = d
        nDotCenter = dot(p.normal, source);
        nDotDir = dot(p.normal, dir);
        t = (-p.d - nDotCenter)/nDotDir;
        pointOfIntersection = source + dir * t;
        if (t <= 0) || (t >= 1)
            % doesn't come between our dest and source
            continue;
        end
        % now project to 2d and count number of times ray intersects plane
        % boundary.
        [checkPoint, delimitingPoints] = project_2d(p, pointOfIntersection);
        if polygonCheck(checkPoint, delimitingPoints)
            occluded = true;
        end
        if occluded
            break;
        end
    end
end

function [point_2d, plane_points_2d] = project_2d(plane_3d, point_3d)
  nx = plane_3d.normal(1);
  ny = plane_3d.normal(2);
  nz = plane_3d.normal(3);
  if (abs(nz) > abs(nx)) && (abs(nz) > abs(ny))
      index1 = 1;
      index2 = 2;
  elseif (abs(ny) > abs(nx))
      index1 = 1;
      index2 = 3;
  else
      index1 = 2;
      index2 = 3;
  end
  xp = point_3d(index1);
  yp = point_3d(index2);
  plane_points_2d = zeros(2,size(plane_3d.vertices,2));
  for j = 1:size(plane_3d.vertices,2)
     plane_points_2d(1,j) = plane_3d.vertices(index1,j);
     plane_points_2d(2,j) = plane_3d.vertices(index2,j);
  end
  point_2d = [xp,yp];
end

function inside = polygonCheck(checkPoint, points)
  % odd number of crossings means inside
  x = checkPoint(1);
  y = checkPoint(2);
  numIntersects = 0;
  inside = false;
  j = size(points,2);
  for i = 1:size(points,2)
      if (((points(2,i) > y) ~= (points(2,j) > y)) && ...
              (x < (points(1,j) - points(1,i)) * (y - points(2,i)) / (points(2,j) - points(2,i)) + points(1,i)))
          inside = ~inside;
          numIntersects = numIntersects + 1;
      end
      j = i;
  end
end