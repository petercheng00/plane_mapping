classdef plane
    %Plane Summary of this class goes here
    %   Detailed explanation goes here
    
    properties
        height;
        width;
        base;
        side;
        down;
        normal;
        d;
        ratio;
        outimg;
        images = [];
        maxshift = 100;
        blendpx = 100;
    end
    
    methods
        function obj = load_images(obj, filenames, masks, rotations, t_cam2world, K)
            n = 1;
            for imgnum = 1:size(filenames,1)
                fprintf('Loading img number %d\tn=%d\n', imgnum,n);
                r = rotations{imgnum};
                t = t_cam2world(imgnum,:)';
                cam_vec = [[0;0;0] r ...
                    * [0;0;1000]] + repmat(t,1,2);
                cam_vec = cam_vec(:,2) - cam_vec(:,1);
                cam_vec = cam_vec / norm(cam_vec);
                if(abs(cam_vec'*obj.normal) < 0.5) continue; end
                
                obj.images = [obj.images plane_img()];
                
                % Load the image and remove the part under the mask
                obj.images(n).img = imread(filenames{imgnum});
                obj.images(n).mask = imread(masks{imgnum}) > 0;
                
                % w is actually height, h is width, but the input images are sideways
                [w h chan] = size(obj.images(n).img);
                assert(chan==3)
                
                % Get the extrinsic matrix
                obj.images(n).r = r;
                obj.images(n).t = t;
                obj.images(n).K = K;
                n = n + 1;
            end
        end
        
        function obj = set_tiles(obj)
            for idx = 1:size(obj.images,2)
                fprintf('Projecting image %d\n', idx);
                obj.images(idx) = obj.images(idx).set_tile_and_rotate(obj);
                imshow(uint8(obj.images(idx).mytile.data));
                drawnow
            end
        end
        
        function obj = print_images(obj)
            for idx = 1:size(obj.images,2)
                fprintf('Printing image %d\n', idx);
                obj = obj.print_tile(obj.images(idx).mytile_on_plane);
                imshow(uint8(obj.outimg));
                drawnow
            end
        end
        
        function obj = print_greedy(obj)
            % Greedy approximation
            grid = false(obj.height,obj.width);
            cost = 0;
            while(1)
                contribution = [];
                for idx = 1:size(obj.images,2)
                    contribution(idx) = obj.images(idx).get_contribution(grid);
                end
                fprintf('contribution sum: %d\n', sum(contribution));
                if(sum(contribution) == 0)
                    break;
                else
                    maxidx = find(contribution == max(contribution),1);
                    cost = cost +  obj.cost_of_tile(obj.images(maxidx).mytile_on_plane);
                    obj = obj.blend_tile(obj.images(maxidx).mytile_on_plane);
                    grid = obj.images(maxidx).update_logical(grid);
                end
            end
            fprintf('cost: %f\n', cost);
        end
        
        function obj = print_greedy_cost(obj)
            % Greedy approximation
            grid = false(obj.height,obj.width);
            cost = 0;
            while(1)
                contribution = [];
                costs = [];
                for idx = 1:size(obj.images,2)
                    costs(idx) = obj.cost_of_tile(obj.images(idx).mytile_on_plane);
                    contribution(idx) = obj.images(idx).get_contribution(grid);
                end
                fprintf('contribution sum: %d\n', sum(contribution));
                if(sum(contribution) == 0)
                    break;
                else            
                    maxidx = find(contribution == max(contribution),1);
                    cost = cost +  obj.cost_of_tile(obj.images(maxidx).mytile_on_plane);
                    obj = obj.blend_tile(obj.images(maxidx).mytile_on_plane);
                    grid = obj.images(maxidx).update_logical(grid);
                end
            end
            fprintf('cost: %f\n', cost);
        end
        
        function obj = print_dynprog(obj)
            % Generate cost DAG
            cost_dag = sparse(eye(size(obj.images,2)));
            % For each starting image
            for idx1 = 1:size(obj.images,2)
                i1 = obj.images(idx1);
                if(~i1.useful) continue; end
                for idx2_i = 1:size(i1.overlap,2)
                    idx2 = i1.overlap(idx2_i);
                    i2 = obj.images(idx2);
                    obj.outimg = zeros(obj.height,obj.width,3);
                    obj = obj.print_tile(i1.mytile_on_plane);
                    cost = obj.cost_of_tile(i2.mytile_on_plane);

                    % End loop if it no longer overlaps
                    if(cost == Inf )
                        fprintf('\n');
                        break
                    else
                        fprintf('Images %d to %d, cost=%f\n', idx1, idx2, cost)
                        cost_dag(idx1,idx2) = cost;
                    end
                end
            end
            
            
            % Ensure graph is connected
            total = sum(sum(cost_dag));
            for idx = 1:size(obj.images,2)-1
                if(cost_dag(idx,idx+1) == 0.0)
                    cost_dag(idx,idx+1) = total;
                end
            end
            
            % Solve shortest path
            memo = ones(1,size(obj.images,2)) .* Inf;
            path = zeros(1,size(obj.images,2));
            memo(1) = 0;
            
            % For each node
            for node = 2:size(obj.images,2)
                % For each node coming in
                for innode = 1:node-1
                    if(cost_dag(innode,node) ~= 0.0)
                        optimal_cost_in = memo(innode) + cost_dag(innode,node);
                        if(optimal_cost_in < memo(node))
                            memo(node) = optimal_cost_in;
                            path(node) = innode;
                        end
                    end
                end
            end
            
            % Backtrack through the array
            valid_img = zeros(1,size(obj.images,2));
            next_node = size(obj.images,2);
            for node = size(obj.images,2):-1:1
                if(node == next_node)
                    valid_img(node) = 1;
                    next_node = path(node);
                end
            end
            
            %Print output
            obj.outimg = zeros(obj.height,obj.width,3);
            for idx = 1:size(obj.images,2)
                if(valid_img(idx))
                    obj = obj.blend_tile(obj.images(idx).mytile_on_plane);
                    imshow(uint8(obj.outimg));
                end
            end
            
        end
        
        function plane_pts = get_plane_pts(obj, box)
            [jj ii] = meshgrid(box.col_min:box.col_max, ...
                box.row_min:box.row_max);
            npoints = prod(size(ii));
            ivec = reshape(ii, [1,npoints]);
            jvec = reshape(jj, [1,npoints]);
            plane_pts = [ivec ; jvec];
        end
        
        function world_pts = get_world_pts(obj, plane_pts)
            npoints = size(plane_pts,2);
            world_pts = repmat(obj.base, [1,npoints]);
            world_pts = world_pts + ...
                repmat(plane_pts(1,:) / obj.height, [3,1]) .* ...
                repmat(obj.down, [1, npoints]);
            world_pts = world_pts + ...
                repmat(plane_pts(2,:) / obj.width, [3,1]) .* ...
                repmat(obj.side, [1, npoints]);
        end
        
        function closest_point = get_closest_plane_point(obj, cam_pt)
            world_pt = cam_pt - ...
                ((cam_pt - obj.base)'*obj.normal)*obj.normal;
            corner_vec = world_pt - obj.base;
            vert = norm(corner_vec'*(obj.down / norm(obj.down)))/norm(obj.down);
            horiz = norm(corner_vec'*(obj.side / norm(obj.side)))/norm(obj.side);
            closest_point = round([vert * obj.height ; horiz * obj.width]);
        end
        
        function obj = sort_images(obj)
            closest_points = [];
            for idx = 1:size(obj.images,2)
                closest_points(:,idx) = ...
                    obj.get_closest_plane_point(obj.images(idx).t);
            end
            vrange = max(closest_points(1,:)) - min(closest_points(1,:));
            hrange = max(closest_points(2,:)) - min(closest_points(2,:));
            I = [];
            if(vrange > hrange)
                [pts I] = sort(closest_points(1,:))
            else
                [pts I] = sort(closest_points(2,:));
            end
            obj.images = obj.images(I);
        end
        
        function box = get_camera_box(obj, cam_pt, radius_in_cm)
            closest_point = obj.get_closest_plane_point(cam_pt);
            radius_pixels = obj.ratio * radius_in_cm;
            box.row_min = closest_point(1) - radius_pixels;
            box.row_max = closest_point(1) + radius_pixels;
            box.col_min = closest_point(2) - radius_pixels;
            box.col_max = closest_point(2) + radius_pixels;
        end
        
        function cost = cost_of_tile(obj, t)
            [h w c] = size(obj.outimg);
            box = t.box;
            existing_tile = obj.outimg(box.row_min:box.row_max,...
                                        box.col_min:box.col_max,:);
            existing_mask = sum(existing_tile,3) > 0;
            added_tile = t.data;
            added_mask = t.border_mask;
            ssd = 0;
            for chan = 1:c
                ssd = ssd + sum(sum((existing_tile(:,:,chan) - ...
                                    added_tile(:,:,chan)).^2 .* ...
                                    added_mask .* existing_mask));
            end
            cost = ssd;
        end
        
        function obj = print_tile(obj, t)
            box = t.box;
            [h w c] = size(obj.outimg);
            for chan = 1:c
                tmp_outimg = obj.outimg(box.row_min:box.row_max, ...
                    box.col_min:box.col_max,chan);
                tmp_tile = t.data(:,:,chan);
                tmp_outimg(t.isvalid) = ...
                    tmp_tile(t.isvalid);
                obj.outimg(box.row_min:box.row_max, ...
                    box.col_min:box.col_max,chan) = tmp_outimg;
            end
        end
        
        function obj = blend_tile(obj, t)
            box = t.box;
            ii = 1;
            for i=box.row_min:box.row_max
                jj = 1;
                for j=box.col_min:box.col_max
                    if(sum(obj.outimg(i,j,:),3)~=0)
                        mindist = min([ii,box.row_max-i,...
                            jj,box.col_max-j,...
                            obj.blendpx]);
                        alpha = mindist/obj.blendpx;
                        obj.outimg(i,j,:) = ...
                            t.data(ii,jj,:)*alpha +...
                            obj.outimg(i,j,:)*(1-alpha);
                    else
                        obj.outimg(i,j,:) = t.data(ii,jj,:);
                    end
                    jj = jj+1;
                end
                ii = ii+1;
            end
        end
        
        function obj = set_tiles_on_plane(obj)
            for idx = 1:size(obj.images,2)
                obj.images(idx) = obj.images(idx).set_tile_on_plane(obj);
            end
        end
        
        function obj = set_sift(obj)
            for idx = 1:size(obj.images,2)
                fprintf('Getting SIFT descriptors for img: %d\n', idx);
                obj.images(idx) = obj.images(idx).set_sift();
            end
        end
        
        function obj = set_overlap(obj, maxoverlap)
            for idx1 = 1:size(obj.images,2)
                limit = min(size(obj.images,2), idx1+maxoverlap);
                for idx2 = idx1+1:limit
                    b1 = obj.images(idx1).mytile_on_plane.box;
                    b2 = obj.images(idx2).mytile_on_plane.box;
                    if(box_overlap(b1, b2, obj.blendpx))
                        obj.images(idx1).overlap = [obj.images(idx1).overlap ...
                            idx2];
                    end
                end
            end
        end
        
        function obj = fix_locations(obj)
            obj = obj.set_overlap(3);
            
            % Fix the positions with least squares
            xmat = zeros(1,size(obj.images,2));
            ymat = zeros(1,size(obj.images,2));
            xobs = [0]; yobs = [0]; w = [0];
            for idx1 = 1:size(obj.images,2)
                if(~obj.images(idx1).useful) continue; end
                s1 = obj.images(idx1);
                for idx2_i = 1:size(s1.overlap,2)
                    idx2 = s1.overlap(idx2_i);
                    if(~obj.images(idx2).useful) continue; end
                    s2 = obj.images(idx2);
                    fprintf('Matching images: %d and %d\n', idx1, idx2)
                    % Shift is the distance from one image to the next
                    [row_shift col_shift] = get_match_and_shift(s1.mytile_on_plane, s2.mytile_on_plane);
                    matches = true;
                    if(row_shift == 0 && col_shift == 0) matches = false; end
                    old_row_shift = s2.mytile_on_plane.box.row_min - s1.mytile_on_plane.box.row_min;
                    old_col_shift = s2.mytile_on_plane.box.col_min - s1.mytile_on_plane.box.col_min;
                    diff = abs(row_shift-old_row_shift) + abs(col_shift-old_col_shift);
                    if(diff < obj.maxshift && matches)
                        fprintf('row_shift: %f\told_row_shift: %f\n', row_shift, old_row_shift);
                        fprintf('col_shift: %f\told_col_shift: %f\n', col_shift, old_col_shift);
                        xmat(end,idx1) = -1; xmat(end,idx2) = 1;
                        ymat(end,idx1) = -1; ymat(end,idx2) = 1;
                        xmat(end+1,:) = 0; ymat(end+1,:) = 0;
                        xobs(end) = col_shift; xobs(end+1) = 0;
                        yobs(end) = row_shift; yobs(end+1) = 0;
                        w(end) = 1; w(end+1) = 0;
                    end
                    xmat(end,idx1) = -1; xmat(end,idx2) = 1;
                    ymat(end,idx1) = -1; ymat(end,idx2) = 1;
                    xmat(end+1,:) = 0; ymat(end+1,:) = 0;
                    xobs(end) = old_col_shift; xobs(end+1) = 0;
                    yobs(end) = old_row_shift; yobs(end+1) = 0;
                    w(end) = 0.01; w(end+1) = 0;
                end
                xmat(end,idx1) = 1;
                ymat(end,idx1) = 1;
                xmat(end+1,:) = 0; ymat(end+1,:) = 0;
                xobs(end) = s1.mytile_on_plane.box.col_min;  xobs(end+1) = 0;
                yobs(end) = s1.mytile_on_plane.box.row_min;  yobs(end+1) = 0;
                w(end) = 0.01; w(end+1) = 0;
            end
            
            xmat(end,1) = 1; ymat(end,1) = 1;
            xobs(end) = obj.images(1).mytile_on_plane.box.col_min;
            yobs(end) = obj.images(1).mytile_on_plane.box.row_min;
            w(end) = 0;
            
            % Solve using weighted least squares
            new_col_mins = lscov(xmat,xobs',w');
            new_row_mins = lscov(ymat,yobs',w');
            
            for idx = 1:size(obj.images,2)
                diff_col = round(new_col_mins(idx) - obj.images(idx).mytile_on_plane.box.col_min);
                diff_row = round(new_row_mins(idx) - obj.images(idx).mytile_on_plane.box.row_min);
                obj.images(idx).mytile.box.col_min = obj.images(idx).mytile.box.col_min + diff_col;
                obj.images(idx).mytile.box.col_max = obj.images(idx).mytile.box.col_max + diff_col;
                obj.images(idx).mytile.box.row_min = obj.images(idx).mytile.box.row_min + diff_row;
                obj.images(idx).mytile.box.row_max = obj.images(idx).mytile.box.row_max + diff_row;
            end
            obj = obj.set_tiles_on_plane();
        end
    end
    
end

